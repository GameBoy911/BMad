# 在“棕地”中工作：完整指南

> **强烈推荐：使用 Gemini Web 或 Gemini CLI 生成“棕地”文档！**
>
> Gemini Web 的 1M+ 令牌上下文窗口或 Gemini CLI（在可用时）可以一次性分析您的**整个**代码库或其关键部分（当然要在合理范围内）：
>
> - 通过 GitHub URL 上传或在项目文件夹中使用 gemini cli
> - 如果在网页版中操作：使用 `npx bmad-method flatten` 将您的项目“扁平化”为单个文件，然后将该文件上传到您的网页代理。

## 什么是“棕地”开发？

“棕地”开发（Brownfield development）指的是为现有软件项目添加功能、修复错误或进行现代化改造。与“绿地”（全新）项目不同，“棕地”工作需要理解现有代码、遵守现有约束，并确保新的更改能够无缝集成，而不会破坏现有功能。

## 何时应为“棕地”项目使用 BMad

- 为现有应用程序添加重要的新功能
- 对遗留代码库进行现代化改造
- 集成新技术或新服务
- 重构复杂系统
- 修复需要理解架构的错误
- 为未文档化的系统编写文档

## 何时不应使用“棕地”流程

如果您刚刚用 BMad 完成了一个最小可行产品（MVP），并希望继续 MVP 后的开发，更简单的方法是直接与产品经理（PM）沟通，请求其与您合作创建一个新的史诗（epic）并添加到产品需求文档（PRD）中，将该史诗进行分片，与架构师一起更新任何架构文档，然后从那里继续。

## 完整的“棕地”工作流

1.  **按照[<ins>用户指南 - 安装</ins>](user-guide.md#installation)中的步骤在网页上设置您的代理。**
2.  **为您的整个代码库生成一个“扁平化”的单一文件**，运行：`npx bmad-method flatten`

### 选择您的方法

#### 方法 A：PRD 优先（推荐用于添加非常庞大和复杂的新功能、单个或多个史诗或大规模变更）

**最适用于**：大型代码库、单一仓库（monorepos），或者当您确切知道要构建什么时

1.  **首先创建 PRD** 以定义需求
2.  仅根据 PRD 的需求**为相关区域编写文档**
3.  **更高效** - 避免为未使用的代码编写文档

#### 方法 B：文档优先（适用于较小的项目）

**最适用于**：较小的代码库、未知的系统或探索性的变更

1.  首先**为整个系统编写文档**
2.  在拥有完整上下文的情况下**创建 PRD**
3.  **更彻底** - 涵盖所有内容

### 方法 A：PRD 优先工作流（推荐）

#### 阶段 1：首先定义需求

**在 Gemini Web 中（已上传您的 flattened-codebase.xml）：**

```bash
@pm
*create-brownfield-prd
```

产品经理（PM）将会：

-   **询问您的增强功能需求**
-   **探索代码库**以了解当前状态
-   **识别需要文档化的受影响区域**
-   **创建范围明确的、重点突出的 PRD**

**关键优势**：PRD 能识别出您的单一仓库/大型代码库中哪些部分**真正**需要文档化！

#### 阶段 2：重点文档化

**仍在 Gemini Web 中，现在有了 PRD 的上下文：**

```bash
@architect
*document-project
```

架构师将会：

-   如果没有提供 PRD，**询问您的关注点**
-   **提供选项**：创建 PRD、提供需求或描述增强功能
-   **参考 PRD/描述**以了解范围
-   **专注于 PRD 或您描述中确定的相关模块**
-   **跳过不相关的区域**以保持文档精简
-   为所有环境**生成一份架构文档**

架构师会创建：

-   **一份遵循 fullstack-architecture 模板的综合架构文档**
-   **在单个文件中涵盖系统的所有方面**
-   **易于复制并另存为** `docs/architecture.md`
-   如果需要，**稍后可以在 IDE 中进行分片**

例如，如果您说“为用户服务添加支付处理功能”：

-   仅文档化：用户服务、API 端点、数据库模式、支付集成
-   创建仅显示与支付相关代码路径的、重点突出的源码树
-   跳过：管理面板、报告模块、不相关的微服务

### 方法 B：文档优先工作流

#### 阶段 1：为现有系统编写文档

**最佳方法 - 使用 Gemini Web 的 1M+ 上下文**：

1.  **前往 Gemini Web** (gemini.google.com)
2.  **上传您的项目**：
    *   **选项 A**：直接粘贴您的 GitHub 仓库 URL
    *   **选项 B**：上传您的 flattened-codebase.xml 文件
3.  **加载架构师代理**：上传 `dist/agents/architect.txt`
4.  **运行文档化**：输入 `*document-project`

架构师将为所有内容生成全面的文档。

#### 阶段 2：规划您的增强功能

##### 选项 A：完整的“棕地”工作流（推荐用于重大变更）

**1. 创建“棕地”PRD**：

```bash
@pm
*create-brownfield-prd```

PM 代理将会：

-   **分析阶段 1 中已有的文档**
-   **向您请求具体的增强功能细节**
-   **评估复杂性**并推荐方法
-   为增强功能**创建史诗/故事结构**
-   **识别风险和集成点**

**PM 代理如何获取项目上下文**：

-   在 Gemini Web 中：通过阶段 1 的文档化，已经拥有了完整的项目上下文
-   在 IDE 中：会询问“请提供您现有项目文档的路径”

**您会遇到的关键提示**：

-   “您想添加什么具体的增强功能或特性？”
-   “这个功能需要与任何现有系统或 API 集成吗？”
-   “我们必须遵守哪些关键约束？”
-   “您的时间表和团队规模是怎样的？”

**2. 创建“棕地”架构**：

```bash
@architect
*create-brownfield-architecture
```

架构师将会：

-   **审查“棕地”PRD**
-   **设计集成策略**
-   如果需要，**规划迁移方法**
-   **识别技术风险**
-   **定义兼容性要求**

##### 选项 B：快速增强（用于重点明确的变更）

**对于没有完整 PRD 的单个史诗**：

```bash
@pm
*create-brownfield-epic
```

在以下情况使用：

-   增强功能定义明确且独立
-   现有文档全面
-   变更不影响多个系统
-   您需要快速交付

**对于单个故事**：

```bash
@pm
*create-brownfield-story
```

在以下情况使用：

-   修复错误或微小功能
-   变更非常独立
-   没有架构影响
-   实现路径清晰

### 阶段 3：验证规划产物

```bash
@po
*execute-checklist-po
```

产品负责人（PO）确保：

-   与现有系统兼容
-   没有计划中的破坏性变更
-   风险缓解策略已到位
-   集成方法清晰

### 阶段 4：保存和分片文档

1.  将您的 PRD 和架构文档保存为：
    docs/prd.md
    docs/architecture.md
    （注意：如果管理多个版本，您可以选择添加 'brownfield-' 前缀）
2.  分片您的文档：
    在您的 IDE 中

    ```bash
    @po
    shard docs/prd.md
    ```

    ```bash
    @po
    shard docs/architecture.md
    ```

### 阶段 5：过渡到开发

**遵循[<ins>增强型 IDE 开发工作流</ins>](enhanced-ide-development-workflow.md)**

## “棕地”最佳实践

### 1. 始终先文档化

即使您认为自己了解代码库：

-   运行 `document-project` 以捕捉当前状态
-   AI 代理需要这个上下文
-   发现未文档化的模式

### 2. 尊重现有模式

“棕地”模板会特别关注：

-   当前的编码约定
-   现有的架构模式
-   技术约束
-   团队偏好

### 3. 规划逐步推出

“棕地”变更应：

-   支持功能标志
-   规划回滚策略
-   包含迁移脚本
-   保持向后兼容性

### 4. 彻底测试集成

#### 为何测试架构师对“棕地”项目至关重要

在“棕地”项目中，测试架构师（Quinn）成为您防止破坏现有功能的安全网。与从零开始构建的“绿地”项目不同，“棕地”项目需要仔细验证新的变更不会动摇已有的功能。

#### “棕地”项目特有的测试挑战

测试架构师解决了“棕地”项目独特的复杂性：

| **挑战** | **测试架构师如何提供帮助** | **命令** |
| :--- | :--- | :--- |
| **回归风险** | 识别哪些现有功能可能会被破坏 | `*risk` |
| **遗留依赖** | 映射集成点和隐藏的依赖关系 | `*trace` |
| **性能下降** | 验证现有流程没有变慢 | `*nfr` |
| **覆盖率缺口** | 找到新变更触及的未经测试的遗留代码 | `*design` |
| **破坏性变更** | 检测 API/合同违规 | `*review` |
| **迁移安全** | 验证数据转换和回滚计划 | `*risk` + `*review` |

#### 完整的“棕地”测试架构师工作流

##### 阶段 1：开发前（风险与策略）

**对“棕地”项目至关重要 - 首先运行这些命令：**

```bash
# 1. 风险评估（在故事创建后立即运行）
@qa *risk {brownfield-story}
# 识别：遗留依赖、破坏性变更、集成点
# 输出：docs/qa/assessments/{epic}.{story}-risk-{YYYYMMDD}.md
# “棕地”项目关注点：
#   - 回归概率评分
#   - 受影响的下游系统
#   - 数据迁移风险
#   - 回滚复杂性

# 2. 测试设计（风险评估后）
@qa *design {brownfield-story}
# 创建：回归测试策略 + 新功能测试
# 输出：docs/qa/assessments/{epic}.{story}-test-design-{YYYYMMDD}.md
# “棕地”项目关注点：
#   - 需要回归测试的现有功能
#   - 集成测试要求
#   - 需要维持的性能基准
#   - 功能标志的测试场景
```

##### 阶段 2：开发期间（持续验证）

**在编码时监控集成健康状况：**

```bash
# 3. 需求追溯（开发中期检查点）
@qa *trace {brownfield-story}
# 映射：新需求 + 现有功能的保留
# 输出：docs/qa/assessments/{epic}.{story}-trace-{YYYYMMDD}.md
# “棕地”项目关注点：
#   - 必须仍然正常工作的现有功能
#   - 新旧功能的交互
#   - API 合同的保留
#   - 缺失的回归测试覆盖率

# 4. 非功能性需求（NFR）验证（在考虑“完成”之前）
@qa *nfr {brownfield-story}
# 验证：性能、安全性、可靠性未改变
# 输出：docs/qa/assessments/{epic}.{story}-nfr-{YYYYMMDD}.md
# “棕地”项目关注点：
#   - 性能回归检测
#   - 集成的安全影响
#   - 向后兼容性验证
#   - 对遗留组件的负载/压力
```

##### 阶段 3：代码审查（深度集成分析）

**全面的“棕地”审查：**

```bash
# 5. 全面审查（开发完成后）
@qa *review {brownfield-story}
# 执行：深度分析 + 主动重构
# 输出：
#   - 故事文件中的 QA 结果
#   - 门禁文件：docs/qa/gates/{epic}.{story}-{slug}.yml
```

审查会特别分析：

-   **API 破坏性变更**：验证所有现有合同得以维持
-   **数据迁移安全**：检查转换逻辑和回滚程序
-   **性能回归**：与基准指标进行比较
-   **集成点**：验证与遗留代码的所有接触点
-   **功能标志逻辑**：确保正确的切换行为
-   **依赖影响**：映射受影响的下游系统

##### 阶段 4：审查后（门禁更新）

```bash
# 6. 门禁状态更新（解决问题后）
@qa *gate {brownfield-story}
# 更新：修复后的质量门禁决策
# 输出：docs/qa/gates/{epic}.{story}-{slug}.yml
# “棕地”项目考虑因素：
#   - 可能会**豁免**某些遗留代码问题
#   - 记录技术债务的接受情况
#   - 跟踪迁移进度
```

#### “棕地”项目特有的风险评分

测试架构师为“棕地”项目使用增强的风险评分：

| **风险类别** | **“棕地”因素** | **对门禁的影响** |
| :--- | :--- | :--- |
| **回归风险** | 集成点数量 × 代码年龄 | 分数 ≥9 = 失败 |
| **数据风险** | 迁移复杂性 × 数据量 | 分数 ≥6 = 需关注 |
| **性能风险** | 当前负载 × 增加的复杂性 | 分数 ≥6 = 需关注 |
| **兼容性风险** | API 消费者数量 × 合同变更 | 分数 ≥9 = 失败 |

#### “棕地”测试标准

Quinn 为“棕地”项目强制执行额外的标准：

-   **回归测试覆盖率**：每个被触及的遗留模块都需要测试
-   **性能基准**：必须维持或改善当前指标
-   **回滚程序**：每个变更都需要一个回滚计划
-   **功能标志**：所有有风险的变更都应置于切换开关之后
-   **集成测试**：覆盖所有遗留接触点
-   **合同测试**：验证 API 兼容性
-   **数据验证**：迁移正确性检查

#### 快速参考：“棕地”测试命令

| **场景** | **要运行的命令** | **顺序** | **为何至关重要** |
| :--- | :--- | :--- | :--- |
| **向遗留代码添加功能** | `*risk` → `*design` → `*trace` → `*review` | 顺序 | 首先映射所有依赖 |
| **API 修改** | `*risk` → `*design` → `*nfr` → `*review` | 顺序 | 防止破坏消费者 |
| **性能关键型变更** | 尽早并频繁地运行 `*nfr` → `*review` | 持续 | 立即捕捉性能下降 |
| **数据迁移** | `*risk` → `*design` → `*trace` → `*review` → `*gate` | 完整周期 | 确保数据完整性 |
| **修复复杂系统中的错误** | `*risk` → `*trace` → `*review` | 重点 | 防止副作用 |

#### 与“棕地”场景的集成

**特定场景指南：**

1.  **遗留代码现代化**
    *   从 `*risk` 开始，映射所有依赖
    *   使用 `*design` 规划绞杀者无花果（strangler fig）模式
    *   频繁运行 `*trace` 以确保没有破坏任何东西
    *   `*review` 侧重于逐步迁移

2.  **向单体应用添加功能**
    *   `*risk` 识别集成复杂性
    *   `*design` 规划隔离策略
    *   `*nfr` 监控性能影响
    *   `*review` 验证没有导致单体应用性能下降

3.  **微服务提取**
    *   `*risk` 映射服务边界
    *   `*trace` 确保功能得以保留
    *   `*nfr` 验证网络开销是否可接受
    *   `*gate` 记录接受的权衡

4.  **数据库模式变更**
    *   `*risk` 评估迁移复杂性
    *   `*design` 规划向后兼容的方法
    *   `*trace` 映射所有受影响的查询
    *   `*review` 验证迁移安全

### 5. 沟通变更

记录：

-   变更了什么以及为什么变更
-   迁移说明
-   引入的新模式
-   弃用通知

## 常见的“棕地”场景

### 场景 1：添加新功能

1.  为现有系统编写文档
2.  创建侧重于集成的“棕地”PRD
3.  **测试架构师早期介入**：
    *   对故事草稿运行 `@qa *risk` 以识别集成风险
    *   使用 `@qa *design` 规划回归测试策略
4.  架构强调兼容性
5.  故事包含带有测试需求的集成任务
6.  **开发期间**：
    *   开发者运行 `@qa *trace` 以验证覆盖率
    *   使用 `@qa *nfr` 监控性能影响
7.  **审查阶段**：`@qa *review` 验证集成安全

### 场景 2：遗留代码现代化

1.  广泛的文档化阶段
2.  PRD 包含迁移策略
3.  **测试架构师策略规划**：
    *   `@qa *risk` 评估现代化改造的复杂性
    *   `@qa *design` 规划并行测试方法
4.  架构规划逐步过渡（绞杀者无花果模式）
5.  故事遵循增量现代化，并包含：
    *   对未触及的遗留代码进行回归测试
    *   对新旧边界进行集成测试
    *   在每个阶段进行性能基准测试
6.  **持续验证**：在每个增量后运行 `@qa *trace`
7.  **门禁管理**：使用 `@qa *gate` 跟踪技术债务的接受情况

### 场景 3：修复复杂系统中的错误

1.  为相关子系统编写文档
2.  使用 `create-brownfield-story` 进行重点修复
3.  **测试架构师风险评估**：运行 `@qa *risk` 以识别潜在的副作用
4.  包含来自 `@qa *design` 输出的回归测试要求
5.  **修复期间**：使用 `@qa *trace` 映射受影响的功能
6.  **提交前**：运行 `@qa *review` 进行全面验证
7.  测试架构师使用以下方法验证没有副作用：
    *   风险分析以评估副作用（概率 × 影响评分）
    *   追溯矩阵以确保修复不会破坏相关功能
    *   非功能性需求（NFR）评估以验证性能/安全未受影响
    *   门禁决策记录修复的安全性

### 场景 4：API 集成

1.  为现有 API 模式编写文档
2.  PRD 定义集成要求
3.  **测试架构师合同分析**：
    *   `@qa *risk` 识别破坏性变更的潜力
    *   `@qa *design` 创建合同测试策略
4.  架构确保模式一致
5.  **API 测试重点**：
    *   用于向后兼容性的合同测试
    *   用于新端点的集成测试
    *   用于新增负载的性能测试
6.  故事包含 API 文档更新
7.  **验证检查点**：
    *   `@qa *trace` 映射所有 API 消费者
    *   `@qa *nfr` 验证响应时间
    *   `@qa *review` 确保没有破坏性变更
8.  **门禁决策**：记录任何被接受的破坏性变更及其迁移路径

## 故障排除

### “AI 不理解我的代码库”

**解决方案**：重新运行 `document-project`，并提供更具体的关键文件路径

### “生成的计划不符合我们的模式”

**解决方案**：在规划阶段之前，用您特定的约定更新生成的文档

### “对于小变更来说，样板文件太多”

**解决方案**：使用 `create-brownfield-story` 而不是完整的工作流

### “集成点不清晰”

**解决方案**：在创建 PRD 期间提供更多上下文，特别强调集成系统

## 快速参考

### “棕地”项目专用命令

```bash
# 为现有项目编写文档
@architect *document-project

# 创建增强功能 PRD
@pm *create-brownfield-prd

# 创建侧重于集成的架构
@architect *create-brownfield-architecture

# 快速创建史诗
@pm *create-brownfield-epic

# 创建单个故事
@pm *create-brownfield-story
```

### 用于“棕地”项目的测试架构师命令

注意：下面显示的是简写形式。完整命令：`*risk-profile`、`*test-design`、`*nfr-assess`、`*trace-requirements`

```bash
# 开发前（规划）
@qa *risk {story}     # 评估回归和集成风险
@qa *design {story}   # 规划回归测试 + 新功能测试

# 开发期间（验证）
@qa *trace {story}    # 验证新旧功能的覆盖率
@qa *nfr {story}      # 检查性能下降

# 开发后（审查）
@qa *review {story}   # 深度集成分析
@qa *gate {story}     # 更新质量决策
```

### 决策树

```text
你是否有一个大型代码库或单一仓库？
├─ 是 → PRD 优先方法
│   └─ 创建 PRD → 仅为受影响的区域编写文档
└─ 否 → 你是否熟悉这个代码库？
    ├─ 是 → PRD 优先方法
    └─ 否 → 文档优先方法

这是一个影响多个系统的重大增强功能吗？
├─ 是 → 完整的“棕地”工作流
│   └─ 始终首先运行测试架构师的 *risk + *design
└─ 否 → 这不仅仅是一个简单的错误修复吗？
    ├─ 是 → *create-brownfield-epic
    │   └─ 运行测试架构师的 *risk 以检查集成点
    └─ 否 → *create-brownfield-story
        └─ 如果触及关键路径，仍然运行 *risk

变更是否触及遗留代码？
├─ 是 → 测试架构师是强制性的
│   ├─ *risk → 识别回归潜力
│   ├─ *design → 规划测试覆盖率
│   └─ *review → 验证没有破坏
└─ 否 → 推荐使用测试架构师
    └─ *review → 确保质量标准
```

## 结论

使用 BMad 方法进行“棕地”开发，在修改现有系统时提供了结构和安全性。测试架构师成为您关键的安全网，通过风险评估、回归测试和持续验证，确保新的变更不会动摇现有功能。

**“棕地”项目的成功公式：**

1.  **先文档化** - 了解现有情况
2.  **尽早评估风险** - 在编码前使用测试架构师的 `*risk`
3.  **规划测试策略** - 设计回归测试 + 新功能测试
4.  **持续验证** - 在开发期间检查集成健康状况
5.  **全面审查** - 在提交前进行深度分析
6.  **果断决策** - 记录质量决策

请记住：**在“棕地”项目中，测试架构师不是可选项——它是您防止生产环境出现故障的保险单。**
